(()=>{class e{constructor(){this.nodeHead=null}prepend(e){let s=null;null!==this.nodeHead&&(s=this.nodeHead),this.nodeHead=new t(e),this.nodeHead.nextNode=s}append(e){if(null===this.nodeHead)return void this.prepend(e);let s=this.nodeHead;for(;null!==s.nextNode;)s=s.nextNode;s.nextNode=new t(e)}replace(e,t){let s=this.nodeHead;for(;null!==s;)s.value.includes(e)&&(s.value[1]=t),s=s.nextNode}find(e){let t=this.nodeHead;for(;null!=t;){if(t.value.includes(e))return t;t=t.nextNode}return null}remove(e){let t=this.nodeHead,s=null;if(this.nodeHead.value.includes(e))this.nodeHead=this.nodeHead.nextNode;else{for(;null!=t&&!t.value.includes(e);)s=t,t=t.nextNode;for(;null===t;)return console.log("No such key found in linked list");s.nextNode=t.nextNode}}returnKeys(){let e=[],t=this.nodeHead;for(;null!==t;)e.push(t.value[0]),t=t.nextNode;return e}returnValues(){let e=[],t=this.nodeHead;for(;null!==t;)e.push(t.value[1]),t=t.nextNode;return e}returnEntries(){let e=[],t=this.nodeHead;for(;null!==t;)e.push([t.value[0],t.value[1]]),t=t.nextNode;return e}}class t{constructor(e=null){this.value=e,this.nextNode=null}}const s=new class{constructor(){this.initialSize=16,this.buckets=new Array(this.initialSize),this.capacity=this.buckets.length,this.loadFactor=.75,this.entries=0}bucketToLinkedList(t,s,n){if(!t.nodeHead){let i=t;return(t=new e).prepend(i),t.append([s,n]),t}return t.append([s,n]),t}checkEntries(){this.entries>=this.capacity*this.loadFactor&&(console.log("growing bucket"),this.growTable())}growTable(){const e=this.buckets;this.capacity=2*this.capacity,this.buckets=new Array(this.capacity);for(const t in e)this.buckets[t]=e[t]}hash(e){let t=0;for(let s=0;s<e.length;s++)t=(31*t+e.charCodeAt(s))%this.capacity;return t}set(e,t){const s=this.hash(e);if(void 0===this.buckets[s])this.buckets[s]=[e,t],this.entries++;else{if(!this.buckets[s].nodeHead){if(this.buckets[s][0]===e)return void(this.buckets[s][1]=t);if(this.buckets[s][0]!==e)return this.checkEntries(),this.buckets[s]=this.bucketToLinkedList(this.buckets[s],e,t),void this.entries++}this.buckets[s].replace(e,t)}}get(e){for(const t in this.buckets)if(this.buckets[t].nodeHead){if(this.buckets[t].nodeHead&&this.buckets[t].find(e))return this.buckets[t].find(e).value[1]}else if(this.buckets[t][0]===e)return this.buckets[t][1];return null}has(e){for(const t in this.buckets)if(this.buckets[t].nodeHead){if(null!==this.buckets[t].find(e))return!0}else if(this.buckets[t].includes(e))return!0;return!1}remove(e){for(const t in this.buckets)if(this.buckets[t].nodeHead){if(this.buckets[t].find(e))return this.buckets[t].remove(e),this.entries--,!0}else if(this.buckets[t].includes(e))return this.buckets.splice(t,1),this.entries--,!0;return!1}length(){return this.entries}clear(){this.buckets=new Array(this.initialSize)}keys(){const e=[];for(const t in this.buckets)this.buckets[t].nodeHead?e.push(...this.buckets[t].returnKeys()):void 0!==this.buckets[t][0]&&e.push(this.buckets[t][0]);return e}values(){const e=[];for(const t in this.buckets)this.buckets[t].nodeHead?e.push(...this.buckets[t].returnValues()):void 0!==this.buckets[t][0]&&e.push(this.buckets[t][1]);return e}entriesF(){const e=[];for(const t in this.buckets)this.buckets[t].nodeHead?e.push(...this.buckets[t].returnEntries()):void 0!==this.buckets[t][0]&&e.push([this.buckets[t][0],this.buckets[t][1]]);return e}};console.log(s),s.set("apple","red"),s.set("banana","yellow"),s.set("carrot","orange"),s.set("dog","brown"),s.set("elephant","gray"),s.set("frog","green"),s.set("grape","purple"),s.set("hat","black"),s.set("ice cream","white"),s.set("jacket","blue"),s.set("kite","pink"),s.set("lion","golden"),s.set("moon","silver"),console.log(s),console.log(s.get("banana")),console.log(s.has("banana")),console.log(s.remove("banana")),console.log(s.get("moon")),console.log(s.length()+" keys"),console.log(s),console.log(s.keys()),console.log(s.values()),console.log(s.entriesF())})();